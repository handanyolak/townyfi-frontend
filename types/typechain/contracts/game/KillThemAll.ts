/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../common";

export declare namespace IKillThemAll {
  export type MaxSettingStruct = {
    health: PromiseOrValue<BigNumberish>;
    mana: PromiseOrValue<BigNumberish>;
    energy: PromiseOrValue<BigNumberish>;
    armor: PromiseOrValue<BigNumberish>;
    teleportDistance: PromiseOrValue<BigNumberish>;
    killArmorRewardLimit: PromiseOrValue<BigNumberish>;
    safeTownDistance: PromiseOrValue<BigNumberish>;
    safeTownDifference: PromiseOrValue<BigNumberish>;
    safeZoneDistance: PromiseOrValue<BigNumberish>;
    safeZoneDifference: PromiseOrValue<BigNumberish>;
    attackDistance: PromiseOrValue<BigNumberish>;
    levelDifference: PromiseOrValue<BigNumberish>;
  };

  export type MaxSettingStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    health: BigNumber;
    mana: BigNumber;
    energy: BigNumber;
    armor: BigNumber;
    teleportDistance: BigNumber;
    killArmorRewardLimit: BigNumber;
    safeTownDistance: BigNumber;
    safeTownDifference: BigNumber;
    safeZoneDistance: BigNumber;
    safeZoneDifference: BigNumber;
    attackDistance: BigNumber;
    levelDifference: BigNumber;
  };

  export type PriceSettingStruct = {
    health: PromiseOrValue<BigNumberish>;
    mana: PromiseOrValue<BigNumberish>;
    energy: PromiseOrValue<BigNumberish>;
    armor: PromiseOrValue<BigNumberish>;
    revive: PromiseOrValue<BigNumberish>;
    register: PromiseOrValue<BigNumberish>;
    teleport: PromiseOrValue<BigNumberish>;
    createTown: PromiseOrValue<BigNumberish>;
    settleTown: PromiseOrValue<BigNumberish>;
    teleportToTown: PromiseOrValue<BigNumberish>;
    prepareAttack: PromiseOrValue<BigNumberish>;
    prepareDefend: PromiseOrValue<BigNumberish>;
  };

  export type PriceSettingStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    health: BigNumber;
    mana: BigNumber;
    energy: BigNumber;
    armor: BigNumber;
    revive: BigNumber;
    register: BigNumber;
    teleport: BigNumber;
    createTown: BigNumber;
    settleTown: BigNumber;
    teleportToTown: BigNumber;
    prepareAttack: BigNumber;
    prepareDefend: BigNumber;
  };

  export type RateSettingStruct = {
    getHealth: PromiseOrValue<BigNumberish>;
    getMana: PromiseOrValue<BigNumberish>;
    getEnergy: PromiseOrValue<BigNumberish>;
    registerReferralReward: PromiseOrValue<BigNumberish>;
    armorAbsorption: PromiseOrValue<BigNumberish>;
    attack: PromiseOrValue<BigNumberish>;
    movement: PromiseOrValue<BigNumberish>;
  };

  export type RateSettingStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    getHealth: BigNumber;
    getMana: BigNumber;
    getEnergy: BigNumber;
    registerReferralReward: BigNumber;
    armorAbsorption: BigNumber;
    attack: BigNumber;
    movement: BigNumber;
  };

  export type TimeSettingStruct = {
    revive: PromiseOrValue<BigNumberish>;
    teleport: PromiseOrValue<BigNumberish>;
    teleportToTown: PromiseOrValue<BigNumberish>;
    attackableAt: PromiseOrValue<BigNumberish>;
    warExpiredAt: PromiseOrValue<BigNumberish>;
    protectionAt: PromiseOrValue<BigNumberish>;
    prepareToAttack: PromiseOrValue<BigNumberish>;
  };

  export type TimeSettingStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    revive: BigNumber;
    teleport: BigNumber;
    teleportToTown: BigNumber;
    attackableAt: BigNumber;
    warExpiredAt: BigNumber;
    protectionAt: BigNumber;
    prepareToAttack: BigNumber;
  };

  export type MinSettingStruct = {
    levelToCreateTown: PromiseOrValue<BigNumberish>;
    townAreaRadius: PromiseOrValue<BigNumberish>;
  };

  export type MinSettingStructOutput = [BigNumber, BigNumber] & {
    levelToCreateTown: BigNumber;
    townAreaRadius: BigNumber;
  };

  export type ExpSettingStruct = {
    kill: PromiseOrValue<BigNumberish>;
    referrerKill: PromiseOrValue<BigNumberish>;
  };

  export type ExpSettingStructOutput = [BigNumber, BigNumber] & {
    kill: BigNumber;
    referrerKill: BigNumber;
  };

  export type MultiplierSettingStruct = {
    attack: PromiseOrValue<BigNumberish>;
    resistance: PromiseOrValue<BigNumberish>;
  };

  export type MultiplierSettingStructOutput = [BigNumber, BigNumber] & {
    attack: BigNumber;
    resistance: BigNumber;
  };

  export type SettingStruct = {
    max: IKillThemAll.MaxSettingStruct;
    price: IKillThemAll.PriceSettingStruct;
    rate: IKillThemAll.RateSettingStruct;
    time: IKillThemAll.TimeSettingStruct;
    min: IKillThemAll.MinSettingStruct;
    exp: IKillThemAll.ExpSettingStruct;
    multiplier: IKillThemAll.MultiplierSettingStruct;
    numberDigits: PromiseOrValue<BigNumberish>;
  };

  export type SettingStructOutput = [
    IKillThemAll.MaxSettingStructOutput,
    IKillThemAll.PriceSettingStructOutput,
    IKillThemAll.RateSettingStructOutput,
    IKillThemAll.TimeSettingStructOutput,
    IKillThemAll.MinSettingStructOutput,
    IKillThemAll.ExpSettingStructOutput,
    IKillThemAll.MultiplierSettingStructOutput,
    BigNumber
  ] & {
    max: IKillThemAll.MaxSettingStructOutput;
    price: IKillThemAll.PriceSettingStructOutput;
    rate: IKillThemAll.RateSettingStructOutput;
    time: IKillThemAll.TimeSettingStructOutput;
    min: IKillThemAll.MinSettingStructOutput;
    exp: IKillThemAll.ExpSettingStructOutput;
    multiplier: IKillThemAll.MultiplierSettingStructOutput;
    numberDigits: BigNumber;
  };

  export type UserLevelStruct = {
    min: PromiseOrValue<BigNumberish>;
    max: PromiseOrValue<BigNumberish>;
  };

  export type UserLevelStructOutput = [BigNumber, BigNumber] & {
    min: BigNumber;
    max: BigNumber;
  };

  export type TownLevelStruct = { maxUser: PromiseOrValue<BigNumberish> };

  export type TownLevelStructOutput = [BigNumber] & { maxUser: BigNumber };

  export type WarStruct = {
    attackerTownId: PromiseOrValue<BigNumberish>;
    defenderTownId: PromiseOrValue<BigNumberish>;
    attackableAt: Timers.BlockNumberStruct;
    expiredAt: Timers.BlockNumberStruct;
  };

  export type WarStructOutput = [
    BigNumber,
    BigNumber,
    Timers.BlockNumberStructOutput,
    Timers.BlockNumberStructOutput
  ] & {
    attackerTownId: BigNumber;
    defenderTownId: BigNumber;
    attackableAt: Timers.BlockNumberStructOutput;
    expiredAt: Timers.BlockNumberStructOutput;
  };

  export type GamePassStruct = {
    pass: PromiseOrValue<string>;
    price: PromiseOrValue<BigNumberish>;
    startBlock: PromiseOrValue<BigNumberish>;
    endBlock: PromiseOrValue<BigNumberish>;
    phaseLimits: PromiseOrValue<BigNumberish>[];
  };

  export type GamePassStructOutput = [
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber[]
  ] & {
    pass: string;
    price: BigNumber;
    startBlock: BigNumber;
    endBlock: BigNumber;
    phaseLimits: BigNumber[];
  };

  export type TownStruct = {
    coordinate: Coordinates.CoordinateStruct;
    name: PromiseOrValue<BytesLike>;
    leader: PromiseOrValue<string>;
    citizens: PromiseOrValue<string>[];
    exp: PromiseOrValue<BigNumberish>;
    levelId: PromiseOrValue<BigNumberish>;
    price: PromiseOrValue<BigNumberish>;
    recruitment: PromiseOrValue<boolean>;
    status: PromiseOrValue<BigNumberish>;
    mode: PromiseOrValue<BigNumberish>;
    protectionAt: Timers.BlockNumberStruct;
  };

  export type TownStructOutput = [
    Coordinates.CoordinateStructOutput,
    string,
    string,
    string[],
    BigNumber,
    BigNumber,
    BigNumber,
    boolean,
    number,
    number,
    Timers.BlockNumberStructOutput
  ] & {
    coordinate: Coordinates.CoordinateStructOutput;
    name: string;
    leader: string;
    citizens: string[];
    exp: BigNumber;
    levelId: BigNumber;
    price: BigNumber;
    recruitment: boolean;
    status: number;
    mode: number;
    protectionAt: Timers.BlockNumberStructOutput;
  };

  export type UserTownInfoStruct = {
    townId: PromiseOrValue<BigNumberish>;
    joinBlock: PromiseOrValue<BigNumberish>;
  };

  export type UserTownInfoStructOutput = [BigNumber, BigNumber] & {
    townId: BigNumber;
    joinBlock: BigNumber;
  };

  export type UserTimerStruct = {
    getHealth: Timers.BlockNumberStruct;
    getMana: Timers.BlockNumberStruct;
    getEnergy: Timers.BlockNumberStruct;
    revive: Timers.BlockNumberStruct;
    teleport: Timers.BlockNumberStruct;
    teleportToTown: Timers.BlockNumberStruct;
    prepareToAttack: Timers.BlockNumberStruct;
  };

  export type UserTimerStructOutput = [
    Timers.BlockNumberStructOutput,
    Timers.BlockNumberStructOutput,
    Timers.BlockNumberStructOutput,
    Timers.BlockNumberStructOutput,
    Timers.BlockNumberStructOutput,
    Timers.BlockNumberStructOutput,
    Timers.BlockNumberStructOutput
  ] & {
    getHealth: Timers.BlockNumberStructOutput;
    getMana: Timers.BlockNumberStructOutput;
    getEnergy: Timers.BlockNumberStructOutput;
    revive: Timers.BlockNumberStructOutput;
    teleport: Timers.BlockNumberStructOutput;
    teleportToTown: Timers.BlockNumberStructOutput;
    prepareToAttack: Timers.BlockNumberStructOutput;
  };

  export type UserCharPointStruct = {
    attack: PromiseOrValue<BigNumberish>;
    defend: PromiseOrValue<BigNumberish>;
  };

  export type UserCharPointStructOutput = [BigNumber, BigNumber] & {
    attack: BigNumber;
    defend: BigNumber;
  };

  export type UserStruct = {
    health: PromiseOrValue<BigNumberish>;
    mana: PromiseOrValue<BigNumberish>;
    energy: PromiseOrValue<BigNumberish>;
    armor: PromiseOrValue<BigNumberish>;
    coordinate: Coordinates.CoordinateStruct;
    name: PromiseOrValue<BytesLike>;
    exp: PromiseOrValue<BigNumberish>;
    levelId: PromiseOrValue<BigNumberish>;
    referrer: PromiseOrValue<string>;
    townInfo: IKillThemAll.UserTownInfoStruct;
    timer: IKillThemAll.UserTimerStruct;
    charPoint: IKillThemAll.UserCharPointStruct;
  };

  export type UserStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    Coordinates.CoordinateStructOutput,
    string,
    BigNumber,
    BigNumber,
    string,
    IKillThemAll.UserTownInfoStructOutput,
    IKillThemAll.UserTimerStructOutput,
    IKillThemAll.UserCharPointStructOutput
  ] & {
    health: BigNumber;
    mana: BigNumber;
    energy: BigNumber;
    armor: BigNumber;
    coordinate: Coordinates.CoordinateStructOutput;
    name: string;
    exp: BigNumber;
    levelId: BigNumber;
    referrer: string;
    townInfo: IKillThemAll.UserTownInfoStructOutput;
    timer: IKillThemAll.UserTimerStructOutput;
    charPoint: IKillThemAll.UserCharPointStructOutput;
  };
}

export declare namespace Coordinates {
  export type CoordinateStruct = {
    _x: PromiseOrValue<BigNumberish>;
    _y: PromiseOrValue<BigNumberish>;
  };

  export type CoordinateStructOutput = [BigNumber, BigNumber] & {
    _x: BigNumber;
    _y: BigNumber;
  };
}

export declare namespace Timers {
  export type BlockNumberStruct = { _at: PromiseOrValue<BigNumberish> };

  export type BlockNumberStructOutput = [BigNumber] & { _at: BigNumber };
}

export interface KillThemAllInterface extends utils.Interface {
  functions: {
    "addGamePass((address,uint256,uint256,uint256,uint256[]))": FunctionFragment;
    "attack(address)": FunctionFragment;
    "buy(uint8,address,uint256)": FunctionFragment;
    "buyGamePass()": FunctionFragment;
    "changeTownRecruitment()": FunctionFragment;
    "claimGamePassReward(uint256)": FunctionFragment;
    "createTown(bytes32,uint256)": FunctionFragment;
    "createTownLevel((uint256))": FunctionFragment;
    "createUserLevel((uint256,uint256))": FunctionFragment;
    "declareWar(uint256)": FunctionFragment;
    "exileCitizen(address)": FunctionFragment;
    "gamePasses(uint256)": FunctionFragment;
    "get(uint8)": FunctionFragment;
    "getAddressesByCoordinate((int64,int64))": FunctionFragment;
    "getCitizensByTownId(uint256)": FunctionFragment;
    "isRegistered(address)": FunctionFragment;
    "isUserClaimedGamePassPhase(address,uint256,uint256)": FunctionFragment;
    "joinTown(uint256)": FunctionFragment;
    "leaveTown()": FunctionFragment;
    "move(uint8)": FunctionFragment;
    "owner()": FunctionFragment;
    "prepareToConditionBonus(uint8,address)": FunctionFragment;
    "register(bytes32,address)": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "revive()": FunctionFragment;
    "setConditionBonus(uint8,bytes32,uint256)": FunctionFragment;
    "settings()": FunctionFragment;
    "settleTown()": FunctionFragment;
    "teleport((int64,int64))": FunctionFragment;
    "teleportToTown()": FunctionFragment;
    "townById(uint256)": FunctionFragment;
    "townIdByCoordinate(int256,int256)": FunctionFragment;
    "townWar()": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "typechainGenerateTown(((int64,int64),bytes32,address,address[],uint256,uint256,uint256,bool,uint8,uint8,(uint256)))": FunctionFragment;
    "typechainGenerateUser((uint256,uint256,uint256,uint256,(int64,int64),bytes32,uint256,uint256,address,(uint256,uint256),((uint256),(uint256),(uint256),(uint256),(uint256),(uint256),(uint256)),(uint256,uint256)))": FunctionFragment;
    "updateSettings(((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),(uint256,uint256,uint256,uint256,uint256,uint256,uint256),(uint256,uint256,uint256,uint256,uint256,uint256,uint256),(uint256,uint256),(uint256,uint256),(uint256,uint256),uint256))": FunctionFragment;
    "upgradeCharacter(uint8,uint256)": FunctionFragment;
    "userByAddr(address)": FunctionFragment;
    "voyageTown()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "addGamePass"
      | "attack"
      | "buy"
      | "buyGamePass"
      | "changeTownRecruitment"
      | "claimGamePassReward"
      | "createTown"
      | "createTownLevel"
      | "createUserLevel"
      | "declareWar"
      | "exileCitizen"
      | "gamePasses"
      | "get"
      | "getAddressesByCoordinate"
      | "getCitizensByTownId"
      | "isRegistered"
      | "isUserClaimedGamePassPhase"
      | "joinTown"
      | "leaveTown"
      | "move"
      | "owner"
      | "prepareToConditionBonus"
      | "register"
      | "renounceOwnership"
      | "revive"
      | "setConditionBonus"
      | "settings"
      | "settleTown"
      | "teleport"
      | "teleportToTown"
      | "townById"
      | "townIdByCoordinate"
      | "townWar"
      | "transferOwnership"
      | "typechainGenerateTown"
      | "typechainGenerateUser"
      | "updateSettings"
      | "upgradeCharacter"
      | "userByAddr"
      | "voyageTown"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "addGamePass",
    values: [IKillThemAll.GamePassStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "attack",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "buy",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "buyGamePass",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "changeTownRecruitment",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "claimGamePassReward",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "createTown",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "createTownLevel",
    values: [IKillThemAll.TownLevelStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "createUserLevel",
    values: [IKillThemAll.UserLevelStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "declareWar",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "exileCitizen",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "gamePasses",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "get",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getAddressesByCoordinate",
    values: [Coordinates.CoordinateStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getCitizensByTownId",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "isRegistered",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isUserClaimedGamePassPhase",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "joinTown",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "leaveTown", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "move",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "prepareToConditionBonus",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "register",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "revive", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "setConditionBonus",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(functionFragment: "settings", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "settleTown",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "teleport",
    values: [Coordinates.CoordinateStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "teleportToTown",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "townById",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "townIdByCoordinate",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "townWar", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "typechainGenerateTown",
    values: [IKillThemAll.TownStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "typechainGenerateUser",
    values: [IKillThemAll.UserStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "updateSettings",
    values: [IKillThemAll.SettingStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeCharacter",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "userByAddr",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "voyageTown",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "addGamePass",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "attack", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "buy", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "buyGamePass",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changeTownRecruitment",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimGamePassReward",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "createTown", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "createTownLevel",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createUserLevel",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "declareWar", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "exileCitizen",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "gamePasses", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "get", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getAddressesByCoordinate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCitizensByTownId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isRegistered",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isUserClaimedGamePassPhase",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "joinTown", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "leaveTown", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "move", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "prepareToConditionBonus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "register", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "revive", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setConditionBonus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "settings", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "settleTown", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "teleport", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "teleportToTown",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "townById", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "townIdByCoordinate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "townWar", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "typechainGenerateTown",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "typechainGenerateUser",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateSettings",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "upgradeCharacter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "userByAddr", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "voyageTown", data: BytesLike): Result;

  events: {
    "LevelUp(address)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "TownCreated()": EventFragment;
    "TownDisbanded(uint256)": EventFragment;
    "TownRecruitmentUpdated()": EventFragment;
    "TownSettled()": EventFragment;
    "TownVoyaged()": EventFragment;
    "UserArmorBroken()": EventFragment;
    "UserAttacked(address,uint256,uint256)": EventFragment;
    "UserBought(uint8,address,uint256,address)": EventFragment;
    "UserBoughtGamePass(uint256)": EventFragment;
    "UserClaimedGamePassPhase(uint256,uint256)": EventFragment;
    "UserExitFromTown(address)": EventFragment;
    "UserGot(uint8,uint256)": EventFragment;
    "UserJoinedTown()": EventFragment;
    "UserKilled(address)": EventFragment;
    "UserMissed()": EventFragment;
    "UserMoved(address,tuple,tuple)": EventFragment;
    "UserPrepared(uint8,bytes32)": EventFragment;
    "UserRegistered()": EventFragment;
    "WarDeclared(tuple)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "LevelUp"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TownCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TownDisbanded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TownRecruitmentUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TownSettled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TownVoyaged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserArmorBroken"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserAttacked"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserBought"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserBoughtGamePass"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserClaimedGamePassPhase"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserExitFromTown"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserGot"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserJoinedTown"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserKilled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserMissed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserMoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserPrepared"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserRegistered"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "WarDeclared"): EventFragment;
}

export interface LevelUpEventObject {
  user: string;
}
export type LevelUpEvent = TypedEvent<[string], LevelUpEventObject>;

export type LevelUpEventFilter = TypedEventFilter<LevelUpEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface TownCreatedEventObject {}
export type TownCreatedEvent = TypedEvent<[], TownCreatedEventObject>;

export type TownCreatedEventFilter = TypedEventFilter<TownCreatedEvent>;

export interface TownDisbandedEventObject {
  townId: BigNumber;
}
export type TownDisbandedEvent = TypedEvent<
  [BigNumber],
  TownDisbandedEventObject
>;

export type TownDisbandedEventFilter = TypedEventFilter<TownDisbandedEvent>;

export interface TownRecruitmentUpdatedEventObject {}
export type TownRecruitmentUpdatedEvent = TypedEvent<
  [],
  TownRecruitmentUpdatedEventObject
>;

export type TownRecruitmentUpdatedEventFilter =
  TypedEventFilter<TownRecruitmentUpdatedEvent>;

export interface TownSettledEventObject {}
export type TownSettledEvent = TypedEvent<[], TownSettledEventObject>;

export type TownSettledEventFilter = TypedEventFilter<TownSettledEvent>;

export interface TownVoyagedEventObject {}
export type TownVoyagedEvent = TypedEvent<[], TownVoyagedEventObject>;

export type TownVoyagedEventFilter = TypedEventFilter<TownVoyagedEvent>;

export interface UserArmorBrokenEventObject {}
export type UserArmorBrokenEvent = TypedEvent<[], UserArmorBrokenEventObject>;

export type UserArmorBrokenEventFilter = TypedEventFilter<UserArmorBrokenEvent>;

export interface UserAttackedEventObject {
  defender: string;
  healthDamage: BigNumber;
  armorDamage: BigNumber;
}
export type UserAttackedEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  UserAttackedEventObject
>;

export type UserAttackedEventFilter = TypedEventFilter<UserAttackedEvent>;

export interface UserBoughtEventObject {
  something: number;
  to: string;
  amount: BigNumber;
  buyer: string;
}
export type UserBoughtEvent = TypedEvent<
  [number, string, BigNumber, string],
  UserBoughtEventObject
>;

export type UserBoughtEventFilter = TypedEventFilter<UserBoughtEvent>;

export interface UserBoughtGamePassEventObject {
  gamePassId: BigNumber;
}
export type UserBoughtGamePassEvent = TypedEvent<
  [BigNumber],
  UserBoughtGamePassEventObject
>;

export type UserBoughtGamePassEventFilter =
  TypedEventFilter<UserBoughtGamePassEvent>;

export interface UserClaimedGamePassPhaseEventObject {
  gamePassId: BigNumber;
  gamePassPhase: BigNumber;
}
export type UserClaimedGamePassPhaseEvent = TypedEvent<
  [BigNumber, BigNumber],
  UserClaimedGamePassPhaseEventObject
>;

export type UserClaimedGamePassPhaseEventFilter =
  TypedEventFilter<UserClaimedGamePassPhaseEvent>;

export interface UserExitFromTownEventObject {
  user: string;
}
export type UserExitFromTownEvent = TypedEvent<
  [string],
  UserExitFromTownEventObject
>;

export type UserExitFromTownEventFilter =
  TypedEventFilter<UserExitFromTownEvent>;

export interface UserGotEventObject {
  something: number;
  amount: BigNumber;
}
export type UserGotEvent = TypedEvent<[number, BigNumber], UserGotEventObject>;

export type UserGotEventFilter = TypedEventFilter<UserGotEvent>;

export interface UserJoinedTownEventObject {}
export type UserJoinedTownEvent = TypedEvent<[], UserJoinedTownEventObject>;

export type UserJoinedTownEventFilter = TypedEventFilter<UserJoinedTownEvent>;

export interface UserKilledEventObject {
  user: string;
}
export type UserKilledEvent = TypedEvent<[string], UserKilledEventObject>;

export type UserKilledEventFilter = TypedEventFilter<UserKilledEvent>;

export interface UserMissedEventObject {}
export type UserMissedEvent = TypedEvent<[], UserMissedEventObject>;

export type UserMissedEventFilter = TypedEventFilter<UserMissedEvent>;

export interface UserMovedEventObject {
  user: string;
  oldCoordinate: Coordinates.CoordinateStructOutput;
  newCoordinate: Coordinates.CoordinateStructOutput;
}
export type UserMovedEvent = TypedEvent<
  [
    string,
    Coordinates.CoordinateStructOutput,
    Coordinates.CoordinateStructOutput
  ],
  UserMovedEventObject
>;

export type UserMovedEventFilter = TypedEventFilter<UserMovedEvent>;

export interface UserPreparedEventObject {
  to: number;
  addressesHash: string;
}
export type UserPreparedEvent = TypedEvent<
  [number, string],
  UserPreparedEventObject
>;

export type UserPreparedEventFilter = TypedEventFilter<UserPreparedEvent>;

export interface UserRegisteredEventObject {}
export type UserRegisteredEvent = TypedEvent<[], UserRegisteredEventObject>;

export type UserRegisteredEventFilter = TypedEventFilter<UserRegisteredEvent>;

export interface WarDeclaredEventObject {
  war: IKillThemAll.WarStructOutput;
}
export type WarDeclaredEvent = TypedEvent<
  [IKillThemAll.WarStructOutput],
  WarDeclaredEventObject
>;

export type WarDeclaredEventFilter = TypedEventFilter<WarDeclaredEvent>;

export interface KillThemAll extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: KillThemAllInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    addGamePass(
      gamePass: IKillThemAll.GamePassStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    attack(
      target: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    buy(
      buy_: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    buyGamePass(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    changeTownRecruitment(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    claimGamePassReward(
      phase: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createTown(
      name: PromiseOrValue<BytesLike>,
      price: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createTownLevel(
      townLevel: IKillThemAll.TownLevelStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createUserLevel(
      userLevel: IKillThemAll.UserLevelStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    declareWar(
      townId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    exileCitizen(
      citizen: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    gamePasses(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber, BigNumber, BigNumber] & {
        pass: string;
        price: BigNumber;
        startBlock: BigNumber;
        endBlock: BigNumber;
      }
    >;

    get(
      get_: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getAddressesByCoordinate(
      coordinate: Coordinates.CoordinateStruct,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    getCitizensByTownId(
      townId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    isRegistered(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isUserClaimedGamePassPhase(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      arg2: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    joinTown(
      townId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    leaveTown(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    move(
      direction: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    prepareToConditionBonus(
      to: PromiseOrValue<BigNumberish>,
      target: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    register(
      name: PromiseOrValue<BytesLike>,
      referrer: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    revive(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setConditionBonus(
      to: PromiseOrValue<BigNumberish>,
      addressesHash: PromiseOrValue<BytesLike>,
      random: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    settings(
      overrides?: CallOverrides
    ): Promise<
      [
        IKillThemAll.MaxSettingStructOutput,
        IKillThemAll.PriceSettingStructOutput,
        IKillThemAll.RateSettingStructOutput,
        IKillThemAll.TimeSettingStructOutput,
        IKillThemAll.MinSettingStructOutput,
        IKillThemAll.ExpSettingStructOutput,
        IKillThemAll.MultiplierSettingStructOutput,
        BigNumber
      ] & {
        max: IKillThemAll.MaxSettingStructOutput;
        price: IKillThemAll.PriceSettingStructOutput;
        rate: IKillThemAll.RateSettingStructOutput;
        time: IKillThemAll.TimeSettingStructOutput;
        min: IKillThemAll.MinSettingStructOutput;
        exp: IKillThemAll.ExpSettingStructOutput;
        multiplier: IKillThemAll.MultiplierSettingStructOutput;
        numberDigits: BigNumber;
      }
    >;

    settleTown(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    teleport(
      coordinate: Coordinates.CoordinateStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    teleportToTown(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    townById(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        Coordinates.CoordinateStructOutput,
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        boolean,
        number,
        number,
        Timers.BlockNumberStructOutput
      ] & {
        coordinate: Coordinates.CoordinateStructOutput;
        name: string;
        leader: string;
        exp: BigNumber;
        levelId: BigNumber;
        price: BigNumber;
        recruitment: boolean;
        status: number;
        mode: number;
        protectionAt: Timers.BlockNumberStructOutput;
      }
    >;

    townIdByCoordinate(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    townWar(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    typechainGenerateTown(
      town: IKillThemAll.TownStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    typechainGenerateUser(
      user: IKillThemAll.UserStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateSettings(
      settings_: IKillThemAll.SettingStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    upgradeCharacter(
      charInfo: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    userByAddr(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        Coordinates.CoordinateStructOutput,
        string,
        BigNumber,
        BigNumber,
        string,
        IKillThemAll.UserTownInfoStructOutput,
        IKillThemAll.UserTimerStructOutput,
        IKillThemAll.UserCharPointStructOutput
      ] & {
        health: BigNumber;
        mana: BigNumber;
        energy: BigNumber;
        armor: BigNumber;
        coordinate: Coordinates.CoordinateStructOutput;
        name: string;
        exp: BigNumber;
        levelId: BigNumber;
        referrer: string;
        townInfo: IKillThemAll.UserTownInfoStructOutput;
        timer: IKillThemAll.UserTimerStructOutput;
        charPoint: IKillThemAll.UserCharPointStructOutput;
      }
    >;

    voyageTown(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  addGamePass(
    gamePass: IKillThemAll.GamePassStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  attack(
    target: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  buy(
    buy_: PromiseOrValue<BigNumberish>,
    to: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  buyGamePass(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  changeTownRecruitment(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  claimGamePassReward(
    phase: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createTown(
    name: PromiseOrValue<BytesLike>,
    price: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createTownLevel(
    townLevel: IKillThemAll.TownLevelStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createUserLevel(
    userLevel: IKillThemAll.UserLevelStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  declareWar(
    townId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  exileCitizen(
    citizen: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  gamePasses(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [string, BigNumber, BigNumber, BigNumber] & {
      pass: string;
      price: BigNumber;
      startBlock: BigNumber;
      endBlock: BigNumber;
    }
  >;

  get(
    get_: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getAddressesByCoordinate(
    coordinate: Coordinates.CoordinateStruct,
    overrides?: CallOverrides
  ): Promise<string[]>;

  getCitizensByTownId(
    townId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string[]>;

  isRegistered(
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isUserClaimedGamePassPhase(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<BigNumberish>,
    arg2: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  joinTown(
    townId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  leaveTown(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  move(
    direction: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  owner(overrides?: CallOverrides): Promise<string>;

  prepareToConditionBonus(
    to: PromiseOrValue<BigNumberish>,
    target: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  register(
    name: PromiseOrValue<BytesLike>,
    referrer: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  renounceOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  revive(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setConditionBonus(
    to: PromiseOrValue<BigNumberish>,
    addressesHash: PromiseOrValue<BytesLike>,
    random: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  settings(
    overrides?: CallOverrides
  ): Promise<
    [
      IKillThemAll.MaxSettingStructOutput,
      IKillThemAll.PriceSettingStructOutput,
      IKillThemAll.RateSettingStructOutput,
      IKillThemAll.TimeSettingStructOutput,
      IKillThemAll.MinSettingStructOutput,
      IKillThemAll.ExpSettingStructOutput,
      IKillThemAll.MultiplierSettingStructOutput,
      BigNumber
    ] & {
      max: IKillThemAll.MaxSettingStructOutput;
      price: IKillThemAll.PriceSettingStructOutput;
      rate: IKillThemAll.RateSettingStructOutput;
      time: IKillThemAll.TimeSettingStructOutput;
      min: IKillThemAll.MinSettingStructOutput;
      exp: IKillThemAll.ExpSettingStructOutput;
      multiplier: IKillThemAll.MultiplierSettingStructOutput;
      numberDigits: BigNumber;
    }
  >;

  settleTown(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  teleport(
    coordinate: Coordinates.CoordinateStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  teleportToTown(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  townById(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [
      Coordinates.CoordinateStructOutput,
      string,
      string,
      BigNumber,
      BigNumber,
      BigNumber,
      boolean,
      number,
      number,
      Timers.BlockNumberStructOutput
    ] & {
      coordinate: Coordinates.CoordinateStructOutput;
      name: string;
      leader: string;
      exp: BigNumber;
      levelId: BigNumber;
      price: BigNumber;
      recruitment: boolean;
      status: number;
      mode: number;
      protectionAt: Timers.BlockNumberStructOutput;
    }
  >;

  townIdByCoordinate(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  townWar(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  typechainGenerateTown(
    town: IKillThemAll.TownStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  typechainGenerateUser(
    user: IKillThemAll.UserStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateSettings(
    settings_: IKillThemAll.SettingStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  upgradeCharacter(
    charInfo: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  userByAddr(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      Coordinates.CoordinateStructOutput,
      string,
      BigNumber,
      BigNumber,
      string,
      IKillThemAll.UserTownInfoStructOutput,
      IKillThemAll.UserTimerStructOutput,
      IKillThemAll.UserCharPointStructOutput
    ] & {
      health: BigNumber;
      mana: BigNumber;
      energy: BigNumber;
      armor: BigNumber;
      coordinate: Coordinates.CoordinateStructOutput;
      name: string;
      exp: BigNumber;
      levelId: BigNumber;
      referrer: string;
      townInfo: IKillThemAll.UserTownInfoStructOutput;
      timer: IKillThemAll.UserTimerStructOutput;
      charPoint: IKillThemAll.UserCharPointStructOutput;
    }
  >;

  voyageTown(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    addGamePass(
      gamePass: IKillThemAll.GamePassStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    attack(
      target: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    buy(
      buy_: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    buyGamePass(overrides?: CallOverrides): Promise<void>;

    changeTownRecruitment(overrides?: CallOverrides): Promise<void>;

    claimGamePassReward(
      phase: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    createTown(
      name: PromiseOrValue<BytesLike>,
      price: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    createTownLevel(
      townLevel: IKillThemAll.TownLevelStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    createUserLevel(
      userLevel: IKillThemAll.UserLevelStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    declareWar(
      townId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    exileCitizen(
      citizen: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    gamePasses(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber, BigNumber, BigNumber] & {
        pass: string;
        price: BigNumber;
        startBlock: BigNumber;
        endBlock: BigNumber;
      }
    >;

    get(
      get_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    getAddressesByCoordinate(
      coordinate: Coordinates.CoordinateStruct,
      overrides?: CallOverrides
    ): Promise<string[]>;

    getCitizensByTownId(
      townId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string[]>;

    isRegistered(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isUserClaimedGamePassPhase(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      arg2: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    joinTown(
      townId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    leaveTown(overrides?: CallOverrides): Promise<void>;

    move(
      direction: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    owner(overrides?: CallOverrides): Promise<string>;

    prepareToConditionBonus(
      to: PromiseOrValue<BigNumberish>,
      target: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    register(
      name: PromiseOrValue<BytesLike>,
      referrer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    revive(overrides?: CallOverrides): Promise<void>;

    setConditionBonus(
      to: PromiseOrValue<BigNumberish>,
      addressesHash: PromiseOrValue<BytesLike>,
      random: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    settings(
      overrides?: CallOverrides
    ): Promise<
      [
        IKillThemAll.MaxSettingStructOutput,
        IKillThemAll.PriceSettingStructOutput,
        IKillThemAll.RateSettingStructOutput,
        IKillThemAll.TimeSettingStructOutput,
        IKillThemAll.MinSettingStructOutput,
        IKillThemAll.ExpSettingStructOutput,
        IKillThemAll.MultiplierSettingStructOutput,
        BigNumber
      ] & {
        max: IKillThemAll.MaxSettingStructOutput;
        price: IKillThemAll.PriceSettingStructOutput;
        rate: IKillThemAll.RateSettingStructOutput;
        time: IKillThemAll.TimeSettingStructOutput;
        min: IKillThemAll.MinSettingStructOutput;
        exp: IKillThemAll.ExpSettingStructOutput;
        multiplier: IKillThemAll.MultiplierSettingStructOutput;
        numberDigits: BigNumber;
      }
    >;

    settleTown(overrides?: CallOverrides): Promise<void>;

    teleport(
      coordinate: Coordinates.CoordinateStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    teleportToTown(overrides?: CallOverrides): Promise<void>;

    townById(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        Coordinates.CoordinateStructOutput,
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        boolean,
        number,
        number,
        Timers.BlockNumberStructOutput
      ] & {
        coordinate: Coordinates.CoordinateStructOutput;
        name: string;
        leader: string;
        exp: BigNumber;
        levelId: BigNumber;
        price: BigNumber;
        recruitment: boolean;
        status: number;
        mode: number;
        protectionAt: Timers.BlockNumberStructOutput;
      }
    >;

    townIdByCoordinate(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    townWar(overrides?: CallOverrides): Promise<void>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    typechainGenerateTown(
      town: IKillThemAll.TownStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    typechainGenerateUser(
      user: IKillThemAll.UserStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    updateSettings(
      settings_: IKillThemAll.SettingStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    upgradeCharacter(
      charInfo: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    userByAddr(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        Coordinates.CoordinateStructOutput,
        string,
        BigNumber,
        BigNumber,
        string,
        IKillThemAll.UserTownInfoStructOutput,
        IKillThemAll.UserTimerStructOutput,
        IKillThemAll.UserCharPointStructOutput
      ] & {
        health: BigNumber;
        mana: BigNumber;
        energy: BigNumber;
        armor: BigNumber;
        coordinate: Coordinates.CoordinateStructOutput;
        name: string;
        exp: BigNumber;
        levelId: BigNumber;
        referrer: string;
        townInfo: IKillThemAll.UserTownInfoStructOutput;
        timer: IKillThemAll.UserTimerStructOutput;
        charPoint: IKillThemAll.UserCharPointStructOutput;
      }
    >;

    voyageTown(overrides?: CallOverrides): Promise<void>;
  };

  filters: {
    "LevelUp(address)"(user?: null): LevelUpEventFilter;
    LevelUp(user?: null): LevelUpEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;

    "TownCreated()"(): TownCreatedEventFilter;
    TownCreated(): TownCreatedEventFilter;

    "TownDisbanded(uint256)"(townId?: null): TownDisbandedEventFilter;
    TownDisbanded(townId?: null): TownDisbandedEventFilter;

    "TownRecruitmentUpdated()"(): TownRecruitmentUpdatedEventFilter;
    TownRecruitmentUpdated(): TownRecruitmentUpdatedEventFilter;

    "TownSettled()"(): TownSettledEventFilter;
    TownSettled(): TownSettledEventFilter;

    "TownVoyaged()"(): TownVoyagedEventFilter;
    TownVoyaged(): TownVoyagedEventFilter;

    "UserArmorBroken()"(): UserArmorBrokenEventFilter;
    UserArmorBroken(): UserArmorBrokenEventFilter;

    "UserAttacked(address,uint256,uint256)"(
      defender?: null,
      healthDamage?: null,
      armorDamage?: null
    ): UserAttackedEventFilter;
    UserAttacked(
      defender?: null,
      healthDamage?: null,
      armorDamage?: null
    ): UserAttackedEventFilter;

    "UserBought(uint8,address,uint256,address)"(
      something?: null,
      to?: null,
      amount?: null,
      buyer?: null
    ): UserBoughtEventFilter;
    UserBought(
      something?: null,
      to?: null,
      amount?: null,
      buyer?: null
    ): UserBoughtEventFilter;

    "UserBoughtGamePass(uint256)"(
      gamePassId?: null
    ): UserBoughtGamePassEventFilter;
    UserBoughtGamePass(gamePassId?: null): UserBoughtGamePassEventFilter;

    "UserClaimedGamePassPhase(uint256,uint256)"(
      gamePassId?: null,
      gamePassPhase?: null
    ): UserClaimedGamePassPhaseEventFilter;
    UserClaimedGamePassPhase(
      gamePassId?: null,
      gamePassPhase?: null
    ): UserClaimedGamePassPhaseEventFilter;

    "UserExitFromTown(address)"(user?: null): UserExitFromTownEventFilter;
    UserExitFromTown(user?: null): UserExitFromTownEventFilter;

    "UserGot(uint8,uint256)"(
      something?: null,
      amount?: null
    ): UserGotEventFilter;
    UserGot(something?: null, amount?: null): UserGotEventFilter;

    "UserJoinedTown()"(): UserJoinedTownEventFilter;
    UserJoinedTown(): UserJoinedTownEventFilter;

    "UserKilled(address)"(user?: null): UserKilledEventFilter;
    UserKilled(user?: null): UserKilledEventFilter;

    "UserMissed()"(): UserMissedEventFilter;
    UserMissed(): UserMissedEventFilter;

    "UserMoved(address,tuple,tuple)"(
      user?: null,
      oldCoordinate?: null,
      newCoordinate?: null
    ): UserMovedEventFilter;
    UserMoved(
      user?: null,
      oldCoordinate?: null,
      newCoordinate?: null
    ): UserMovedEventFilter;

    "UserPrepared(uint8,bytes32)"(
      to?: null,
      addressesHash?: null
    ): UserPreparedEventFilter;
    UserPrepared(to?: null, addressesHash?: null): UserPreparedEventFilter;

    "UserRegistered()"(): UserRegisteredEventFilter;
    UserRegistered(): UserRegisteredEventFilter;

    "WarDeclared(tuple)"(war?: null): WarDeclaredEventFilter;
    WarDeclared(war?: null): WarDeclaredEventFilter;
  };

  estimateGas: {
    addGamePass(
      gamePass: IKillThemAll.GamePassStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    attack(
      target: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    buy(
      buy_: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    buyGamePass(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    changeTownRecruitment(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    claimGamePassReward(
      phase: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createTown(
      name: PromiseOrValue<BytesLike>,
      price: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createTownLevel(
      townLevel: IKillThemAll.TownLevelStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createUserLevel(
      userLevel: IKillThemAll.UserLevelStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    declareWar(
      townId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    exileCitizen(
      citizen: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    gamePasses(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    get(
      get_: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getAddressesByCoordinate(
      coordinate: Coordinates.CoordinateStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getCitizensByTownId(
      townId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isRegistered(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isUserClaimedGamePassPhase(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      arg2: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    joinTown(
      townId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    leaveTown(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    move(
      direction: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    prepareToConditionBonus(
      to: PromiseOrValue<BigNumberish>,
      target: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    register(
      name: PromiseOrValue<BytesLike>,
      referrer: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    revive(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setConditionBonus(
      to: PromiseOrValue<BigNumberish>,
      addressesHash: PromiseOrValue<BytesLike>,
      random: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    settings(overrides?: CallOverrides): Promise<BigNumber>;

    settleTown(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    teleport(
      coordinate: Coordinates.CoordinateStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    teleportToTown(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    townById(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    townIdByCoordinate(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    townWar(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    typechainGenerateTown(
      town: IKillThemAll.TownStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    typechainGenerateUser(
      user: IKillThemAll.UserStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateSettings(
      settings_: IKillThemAll.SettingStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    upgradeCharacter(
      charInfo: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    userByAddr(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    voyageTown(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    addGamePass(
      gamePass: IKillThemAll.GamePassStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    attack(
      target: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    buy(
      buy_: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    buyGamePass(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    changeTownRecruitment(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    claimGamePassReward(
      phase: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createTown(
      name: PromiseOrValue<BytesLike>,
      price: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createTownLevel(
      townLevel: IKillThemAll.TownLevelStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createUserLevel(
      userLevel: IKillThemAll.UserLevelStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    declareWar(
      townId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    exileCitizen(
      citizen: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    gamePasses(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    get(
      get_: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getAddressesByCoordinate(
      coordinate: Coordinates.CoordinateStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getCitizensByTownId(
      townId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isRegistered(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isUserClaimedGamePassPhase(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      arg2: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    joinTown(
      townId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    leaveTown(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    move(
      direction: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    prepareToConditionBonus(
      to: PromiseOrValue<BigNumberish>,
      target: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    register(
      name: PromiseOrValue<BytesLike>,
      referrer: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    revive(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setConditionBonus(
      to: PromiseOrValue<BigNumberish>,
      addressesHash: PromiseOrValue<BytesLike>,
      random: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    settings(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    settleTown(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    teleport(
      coordinate: Coordinates.CoordinateStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    teleportToTown(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    townById(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    townIdByCoordinate(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    townWar(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    typechainGenerateTown(
      town: IKillThemAll.TownStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    typechainGenerateUser(
      user: IKillThemAll.UserStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateSettings(
      settings_: IKillThemAll.SettingStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    upgradeCharacter(
      charInfo: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    userByAddr(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    voyageTown(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
